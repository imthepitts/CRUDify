component accessors="true" {

    // --------------------------------------------------------------------------
    // Properties that should be explicitly defined during object initialization.
    // --------------------------------------------------------------------------
    
    /**    
     * @hint Base table for the gateway to use. This table will be used for CRUD operations.
     */ 
    property string tableName;

    /**    
     * @hint For gateway queries, supply an optional alternate table name or
     * the name of a database view that will provide basis for queries using view(). 
     * Defaults to tableName.
     */ 
    property string viewName;
    
    /**    
     * @hint Supply an optional short list of column names to be used in gateway queries, if 
     * there are many unneeded columns in the base table.  
     */
    property string shortList;
    
    /**    
     * @hint Set the default sort (ex: 'lastName ASC') of gateway queries. If no default is set, 
     * results will be sorted by the primary key. 
     */
    property string defaultSort;
    

    // -----------------------------------------------------------
    // Properties that are automatically loaded from DB meta data.
    // -----------------------------------------------------------
    
    /**    
     * @hint Structure where DB metadata is stored. 
     */     
    property struct metaData;
    
    /**    
     * @hint Primary key of the table. If compound key, column names will be stored as a list. 
     */
    property string primaryKey;
    
    /**    
     * @hint Primary key uses identity to generate IDs. 
     */
    property boolean hasIdentity;
    
    /**    
     * @hint Full column list for the table. 
     */
    property string columnList;
    

    // -----------------------------------------------------------
    // INJECTED DEPENDENCIES
    // -----------------------------------------------------------
        
    /**    
     * @hint Accessor for view gateway. Automatically set during init() when viewName is provided.  
     */
    property Gateway viewGateway;
        

    // -----------------------------------------------------------
    // METHODS
    // -----------------------------------------------------------
        
    /**    
     * @hint Constructor automatically loads meta data from DB. If overriding init() in another CFC, 
     * be sure to call super.init() to ensure this load occurs.
     */
    public Gateway function init(string tableName=getTableNameFromCFC(), string viewName, string shortList, string defaultSort){
        structAppend(variables, arguments);
        variables.primaryKey = '';
        variables.hasIdentity = false;
        loadMetaData();
        initializeViewGateway();
        return this;
    }
        
    /**    
     * @hint Combined method (insert/update) for saving a record. Only works if primary key values
     * are included in the values structure. 
     */
    public struct function save(required struct values){
        // Saving is destructive to the original values struct. Duplicate it to keep original intact. 
        var theValues = duplicate(values);

        // Verify primary key is contained in the values structure.
        if (isPrimaryKeyInValues(theValues)){
            // Retrieve the primary key value.
            var keyValue = getKeyValue(theValues);
            // If table uses identity and primary key value is a representation of 'null', perform insert.
            if (variables.hasIdentity && isKeyValueNull(keyValue)){
                // Remove the primary key value from the set of values so it can be autogenerated.
                removeKeyValueFromValues(keyValue, theValues);
                // Return the generated key.
                var generatedKey = create(theValues);
                for (var id in keyValue){
                    keyValue[id] = generatedKey;
                }
            } 
            // If it's not an identity primary key, see if the record already exists in the table. If not, insert.  
            else if (!this.find(keyValue, 'count').getResult().count){
                create(theValues);
            } 
            // Otherwise, try to update the record.
            else {
                removeKeyValueFromValues(keyValue, theValues);
                update(theValues, keyValue);
            }
            return keyValue;
        } 
        
        // Throw error if primary key is not present in the values, as primary key value is required for a single record save.
        else {
            throw('Primary key ''#variables.primaryKey#'' not present in values structure.', '', 'The save() method is for single row modifications and, therefore, can only be used if the primary key is included in the values struct.');
        }
    }
    
    /**    
     * @hint Inserts a record into the table and returns generated key, if applicable. Sets nullable columns to null 
     * if empty string. Automatically detects SQL data types and passes the values as parameters (cfqueryparam). 
     */
    public any function create(required struct values){
        // Saving is destructive to the original values struct. Duplicate it to keep original intact. 
        var theValues = duplicate(values);

        var query = new Query();

        // Remove any values that don't match the column names in the table.
        validateColumns(theValues);
        
        var columns = structKeyList(theValues);
        var columnsArray = listToArray(columns);
        
        // Assemble the insert statement.
        var sql = 'INSERT INTO #variables.tableName# (#columns#) VALUES ( ';
        var i = 0;
        var count = structCount(theValues);
        var result = '';
        for (var item in columnsArray){
            var attribs = {
                name=item, 
                value=theValues[item], 
                cfsqltype=translateSqlType(variables.metaData[variables.tableName][item].TYPE_NAME),  
                null=variables.metaData[variables.tableName][item].IS_NULLABLE && !len(theValues[item])
            };
            if (variables.metaData[variables.tableName][item].DECIMAL_DIGITS){
                attribs.scale = variables.metaData[variables.tableName][item].DECIMAL_DIGITS;
            }
            query.addParam(argumentCollection=attribs);
            sql &= ':#item# ';
            i++;
            if (i < count){
                sql &= ', ';
            }
        }
        sql &= ') ';
        
        // Execute the SQL
        result = query.execute(sql=sql);
        
        // Return the generated key, if this table has identity primary key. 
        if (variables.hasIdentity){
            return result.getPrefix().generatedkey;
        }
    }
    
    /**    
     * @hint Convenience method for retrieving a single record based on primary key. Converts query into a struct.  
     */
    public any function read(required any keyValue){
        // If primary key is a single column, set into a structure to pass into find() method.
        if (!isStruct(keyValue)){
            keyValue = {'#variables.primaryKey#' = keyValue};
        }
        return queryToStruct(this.find(keyValue).getResult());
    }
    
    /**    
     * @hint Variation of read() when targeting the view instead of the base table.  
     */
    public any function readFromView(required any keyValue){
        // If primary key is a single column, set into a structure to pass into find() method.
        if (!isStruct(keyValue)){
            keyValue = {'#variables.primaryKey#' = keyValue};
        }
        return queryToStruct(view(keyValue).getResult());
    }
    
    /**    
     * @hint Updates one or more rows in the table. Automatically detects SQL data types and passes the 
     * values as parameters (cfqueryparam). Sets nullable columns to null if empty string. Returns the 
     * number of affected records.
     */
    public numeric function update(required struct values, required struct criteria){
        
        // Saving is destructive to the original values struct. Duplicate it to keep original intact. 
        var theValues = duplicate(values);
        
        // Prevent updating the entire table.
        if (structIsEmpty(criteria)){
            throw('Criteria must be provided.', '', 'Provide criteria for the update as a struct. No criteria would update the entire table. And that''s probably not what you want to do. Right?');
        }
        var query = new Query();
        var sql = 'UPDATE #variables.tableName# SET ';
        var i = 0;
        
        // Remove any values that don't match columns in the table.
        validateColumns(theValues);
        var count = structCount(theValues);
        
        // Assemble the update statement.
        for (var item in theValues){
            var attribs = {
                name='#item#Val', 
                value=theValues[item], 
                cfsqltype=translateSqlType(variables.metaData[variables.tableName][item].TYPE_NAME), 
                null=variables.metaData[variables.tableName][item].IS_NULLABLE && !len(theValues[item])
            };
            if (variables.metaData[variables.tableName][item].DECIMAL_DIGITS){
                attribs.scale=variables.metaData[variables.tableName][item].DECIMAL_DIGITS; 
            }
            query.addParam(argumentCollection=attribs);
            sql &= '#item# = :#item#Val ';
            i++;
            if (i < count){
                sql &= ', ';
            }
        }
        
        // Assemble WHERE clause with CFQUERYPARAMs
        sql &= 'WHERE 0=0 ';
        for (var param in criteria){
            var attribs = {
                name='#param#Param', 
                value=criteria[param], 
                cfsqltype=translateSqlType(variables.metaData[variables.tableName][param].TYPE_NAME)
            };
            if (variables.metaData[variables.tableName][param].DECIMAL_DIGITS){
                attribs.scale=variables.metaData[variables.tableName][param].DECIMAL_DIGITS;
            }
            query.addParam(argumentCollection=attribs);
            sql &= 'AND #param# = :#param#Param ';
        }
        
        // Execute SQL and return count of affected records
        return query.execute(sql=sql).getPrefix().recordCount;
    }
    
    /**    
     * @hint Deletes record from the table. Returns the number of affected records.
     */
    public numeric function delete(required struct criteria){
        var query = new Query();
        var sql = 'DELETE FROM #variables.tableName# WHERE 0=0 ';
        
        // Validate the columns being used as criteria.
        validateColumns(criteria);
        
        // Prevent deleting of all data in the table.
        if (structIsEmpty(criteria)) throw('No valid critiera was specified. All data would be deleted.', '', 'Check the criteria structure to ensure keys match valid column names.');
        
        // Assemble the WHERE clause
        for (var param in criteria){
            query.addParam(name=param, value=criteria[param], cfsqltype=translateSqlType(variables.metaData[variables.tableName][param].TYPE_NAME));
            sql &= 'AND #param# = :#param# ';
        }
        
        // Execute the SQL and return count of affected rows.
        return query.execute(sql=sql).getPrefix().recordCount;
    }
    
    /**    
     * @hint Generic gateway query method for the table.
     */
    public struct function find(struct criteria={}, string columns=variables.columnList, string sort=getDefaultSort(), struct pagination={}, string strategy=''){
        if (len(strategy)) {
            return evaluate('find#strategy#(argumentCollection=arguments)');
        }
        else {
            return createGatewayQuery(tableName=variables.tableName, criteria=arguments.criteria, columns=translateColumns(arguments.columns), sort=arguments.sort, pagination=arguments.pagination).bind().execute();
        }
    }
        
    /**    
     * @hint Generic gateway query method for the view.
     */
    public struct function view(struct criteria={}, string columns=getViewGateway().getColumnList(), string sort=getViewGateway().getDefaultSort(), struct pagination={}, string strategy=''){
        if (len(strategy)) {
            return evaluate('view#strategy#(argumentCollection=arguments)');
        } 
        else {
            return getViewGateway().find(argumentCollection=arguments);
        }
    }
    
    /**    
     * @hint Wrapper function for creating a new GatewayQuery. 
     */
    public GatewayQuery function createGatewayQuery(required string tableName, struct criteria={}, required any columns, string sort='', struct pagination={}){
        return new GatewayQuery(argumentCollection=arguments);
    }

    public GatewayCriteria function createGatewayCriteria(struct criteria={}){
        return new GatewayCriteria(argumentCollection=arguments);
    }
        
    /**
     * @hint Returns the first row of a query as a structure with same case as query column names.
     */
    public struct function queryToStruct(required query query, numeric rowNumber=1){

        var struct = {};
        var columns = arguments.query.getMeta().getColumnLabels();
        
        for (var i = 1; i <= arrayLen(columns); i++){
            struct[columns[i]] = query[columns[i]][arguments.rowNumber];
        }
        
        return struct;
    }
    
    /**
     * @hint Converts a multi-row query to a structure in a pivot manner, using values from a 
     * specified column as the structure's keys and the values from a specified column as the 
     * structure's values. If no column specified for the values, the entire query row will be 
     * converted to a struct and stored for the key.
     */
    public struct function queryToStructPivot(required query query, required string columnAsKey, string columnAsValue){
        var struct = {};
        for (var i = 1; i <= query.recordCount; i++){
            var name = query[columnAsKey][i];
            var val = (isNull(columnAsValue) ? queryToStruct(query, i): query[columnAsValue][i]);
            struct[name] = val;
        }
        return struct;
    }
    
    /**
     * @hint Converts a multi-row query to a structure in a pivot manner, using values from a 
     * specified column as the structure's keys and the values from a specified column as the 
     * structure's values. Multiple values for the same key will be combined into an array.
     */
    public struct function queryToStructPivotMultiValue(required query query, required string columnAsKey, string columnAsValue){
        var struct = {};
        for (var i = 1; i <= query.recordCount; i++){
            var name = query[columnAsKey][i];
            var val = (isNull(columnAsValue) ? queryToStruct(query, i): query[columnAsValue][i]);
            if (structKeyExists(struct, name)){
                if (!isArray(struct[name])){
                    struct[name] = [struct[name]];
                }
                arrayAppend(struct[name], val);
            } else {
                struct[name] = val;
            }
        }
        return struct;
    }    
    
    /**
     * @hint Converts a query to an array of structures.
     */
    public array function queryToArray(required query query){
        var result = [];
        for (var i = 1; i <= query.recordCount; i++){
            arrayAppend(result, queryToStruct(query, i));
        }
        return result;
    }
     
    public struct function addDefaults(struct values={}){
        var defaults = {};
        var metaData = this.getMetaData()[variables.tableName];
        var query = new Query();
        var sql = 'SELECT 1';
        for (var column in metaData){
            if (len(metaData[column].COLUMN_DEFAULT_VALUE)){
                sql &= ',#metaData[column].COLUMN_DEFAULT_VALUE# AS #column#';
            }
        }
        defaults = queryToStruct(query.execute(sql=sql).getResult());        
        for (var item in defaults){
            if (len(defaults[item])){
                if (!structKeyExists(values, item) || !len(values[item])){
                    values[item] = defaults[item];
                }
            }
        }
        return values;
    }
    
    
    // --------------------------------------------------------------------------
    // ACCESSORS
    // --------------------------------------------------------------------------
    
    public string function getDefaultSort(){
        if (isNull(variables.defaultSort) || !len(variables.defaultSort)){
            variables.defaultSort = variables.primaryKey;
        }         
        return variables.defaultSort;    
    }
    
    public struct function getKeyValue(required struct values){
        var key = '';
        var keyValue = {};
        var primaryKeyList = listToArray(variables.primaryKey);
        if (!arrayLen(primaryKeyList)){
            throw('PrimaryKey not set. You must set primaryKey for this #variables.tableName# gateway before you can retrieve the keyValue.', '', 'Set primaryKey to the name or list of names identifying the unique key for this gateway/table.');
        }
        for (var key in primaryKeyList){
            if (structKeyExists(values, key)){
                keyValue[key] = values[key];
            } 
        }
        return keyValue;
    }
    

    // --------------------------------------------------------------------------
    // PRIVATE METHODS
    // --------------------------------------------------------------------------

    private boolean function isPrimaryKeyInValues(required struct values){
        if(!len(variables.primaryKey)){             
            throw('PrimaryKey not set. You must set primaryKey for table ''#variables.tableName#'' gateway before you can retrieve the keyValue.', '', 'Set primaryKey to the name or list of names identifying the unique key for this gateway/table.');
        }
        var primaryKeyList = listToArray(uCase(variables.primaryKey));
        var valuesList = listToArray(uCase(structKeyList(values)));
        for (var item in primaryKeyList){
            if (!arrayFind(valuesList, item)) return false;
        }
        return true;
    }
    
    private boolean function isKeyValueNull(required struct keyValue){
        for (var item in keyValue){
            var val = keyValue[item];
            if (!len(val) || val == 0) return true;
        }
        return false;
    }

    private void function removeKeyValueFromValues(required struct keyValue, required struct values){
        for (var item in keyValue){
            structDelete(values, item);
        }
    }
    
    private void function validateColumns(required struct values){
        for (var item in values){
            if (!structKeyExists(variables.metaData[variables.tableName], item)){
                structDelete(values, item);
            }
        }
    }
    
    private string function translateSqlType(required string sqlType){
        sqlType = listFirst(sqlType, ' ');
        var map = {
            bigint = 'CF_SQL_BIGINT',
            binary = 'CF_SQL_BINARY',
            bit = 'CF_SQL_BIT',
            char = 'CF_SQL_CHAR',
            datetime = 'CF_SQL_TIMESTAMP',
            decimal = 'CF_SQL_DECIMAL',
            float = 'CF_SQL_FLOAT',
            image = 'CF_SQL_BINARY',
            int = 'CF_SQL_INTEGER',
            integer = 'CF_SQL_INTEGER',
            longvarbinary = 'CF_SQL_BLOB',
            longvarchar = 'CF_SQL_LONGVARCHAR',
            money = 'CF_SQL_MONEY',
            nchar = 'CF_SQL_CHAR',
            numeric = 'CF_SQL_NUMERIC',
            nvarchar = 'CF_SQL_VARCHAR',            
            real = 'CF_SQL_REAL',
            smalldatetime = 'CF_SQL_TIMESTAMP',
            smallint = 'CF_SQL_SMALLINT',
            smallmoney = 'CF_SQL_MONEY',            
            time  = 'CF_SQL_TIME',
            tinyint = 'CF_SQL_TINYINT',
            timestamp = 'CF_SQL_BINARY',
            varbinary = 'CF_SQL_VARBINARY',
            varchar = 'CF_SQL_VARCHAR',            
            text = 'CF_SQL_LONGVARCHAR'            
        };
        if (!structKeyExists(map, sqlType)){
            return map['varchar'];
        } else {
            return map[sqlType];
        }
    }
    
    private string function getTableNameFromCFC(){
        var meta = getMetaData(this);
        if (!isNull(meta.table)) return meta.table;
        else return '';
    }
    
    private string function translateColumns(required string columns){
        switch (arguments.columns){
            case 'long':
                arguments.columns = variables.columnList;
                break;
            case 'short':
                arguments.columns = variables.shortList;
                break;
            case 'count':
                arguments.columns = 'COUNT(*) AS COUNT';
            default:
                // keep whatever was passed in
                break;
        }
        return arguments.columns;
    }
    
    /**    
     * @hint Loads meta data from the DB. Used for verifying primary keys, identity columns and the like. 
     */
    private void function loadMetaData(){
        // Retrieve table meta data form the DB.
        var columnData = new dbinfo().columns(table=variables.tableName);
        var columnName = '';
        
        variables.metaData[variables.tableName] = {};
        
        // Populate the meta data structure using column names as keys.
        for (var i = 1; i <= columnData.recordCount; i++){
            columnName = columnData.COLUMN_NAME[i];
            variables.metaData[variables.tableName][columnName] = queryToStruct(columnData, i);
            
            // Set the primary key column name(s).
            if (variables.metaData[variables.tableName][columnName].IS_PRIMARYKEY) {
                variables.primaryKey = listAppend(variables.primaryKey, columnName);
                
                // If primary key uses identity, set identity flag.
                if (variables.metaData[variables.tableName][columnName].TYPE_NAME contains 'identity') {
                    variables.hasIdentity = true;
                }
            }
        }
        
        // Default column lists to the entire list.
        variables.columnList = structKeyList(variables.metaData[variables.tableName]);
        variables.shortList = variables.columnList;
        
    }
    
    private void function initializeViewGateway(){
        if (isNull(variables.viewName)){
            variables.viewName = variables.tableName;
        }
        if (variables.tableName != variables.viewName){
            variables.viewGateway = new Gateway(variables.viewName);
        } else {
            variables.viewGateway = this;
        }
    }
}